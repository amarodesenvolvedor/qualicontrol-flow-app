
import { supabase } from '@/integrations/supabase/client';
import { NonConformance, NonConformanceFilter, NonConformanceCreateData, NonConformanceUpdateData } from '@/types/nonConformance';

// Function to fetch all non conformances with filters
export const fetchNonConformances = async (filters: NonConformanceFilter): Promise<NonConformance[]> => {
  let query = supabase
    .from('non_conformances')
    .select(`
      *,
      department:department_id (
        id,
        name
      )
    `)
    .order('created_at', { ascending: false });

  // Apply filters
  if (filters.status) {
    query = query.eq('status', filters.status);
  }

  if (filters.category) {
    query = query.eq('category', filters.category);
  }

  if (filters.departmentId) {
    query = query.eq('department_id', filters.departmentId);
  }

  if (filters.dateRange?.from) {
    query = query.gte('occurrence_date', filters.dateRange.from.toISOString().split('T')[0]);
  }

  if (filters.dateRange?.to) {
    query = query.lte('occurrence_date', filters.dateRange.to.toISOString().split('T')[0]);
  }

  if (filters.searchTerm) {
    query = query.ilike('title', `%${filters.searchTerm}%`);
  }

  const { data, error } = await query;

  if (error) {
    console.error('Error fetching non conformances:', error);
    throw new Error('Error fetching non conformances');
  }

  return data as unknown as NonConformance[];
};

// Create a new non-conformance
export const createNonConformance = async (data: NonConformanceCreateData): Promise<NonConformance> => {
  // Type assertion to satisfy TypeScript
  const insertData = {
    title: data.title,
    description: data.description,
    location: data.location,
    department_id: data.department_id,
    category: data.category,
    immediate_actions: data.immediate_actions,
    responsible_name: data.responsible_name,
    auditor_name: data.auditor_name,
    occurrence_date: data.occurrence_date,
    deadline_date: data.deadline_date,
    status: data.status,
    // The code field will be auto-generated by a database trigger
    code: 'NC-TEMP' // This value will be overwritten by the trigger
  };

  const { error, data: result } = await supabase
    .from('non_conformances')
    .insert(insertData)
    .select()
    .single();

  if (error) throw new Error(error.message);

  return result as unknown as NonConformance;
};

// Update an existing non-conformance
export const updateNonConformance = async (id: string, data: NonConformanceUpdateData): Promise<NonConformance> => {
  const { data: updatedData, error } = await supabase
    .from('non_conformances')
    .update(data)
    .eq('id', id)
    .select()
    .single();

  if (error) {
    console.error('Error updating non-conformance:', error);
    throw new Error('Error updating non-conformance');
  }

  return updatedData as unknown as NonConformance;
};

// Delete a non-conformance
export const deleteNonConformance = async (id: string): Promise<{ success: boolean }> => {
  const { error } = await supabase
    .from('non_conformances')
    .delete()
    .eq('id', id);

  if (error) throw error;

  return { success: true };
};

// Upload files to Supabase storage
export const uploadFilesToStorage = async (files: File[]): Promise<string[]> => {
  const uploadPromises = files.map(async (file) => {
    const fileName = `${Date.now()}_${file.name}`;
    const filePath = `evidences/${fileName}`;

    const { error } = await supabase.storage
      .from('non_conformance_files')
      .upload(filePath, file);

    if (error) {
      throw error;
    }

    return filePath;
  });

  return Promise.all(uploadPromises);
};

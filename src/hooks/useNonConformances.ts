
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { toast } from '@/hooks/use-toast';
import type { Department } from '@/hooks/useDepartments';

export type NonConformance = {
  id: string;
  code: string;
  title: string;
  description: string | null;
  location: string | null;
  department_id: string;
  category: string;
  immediate_actions: string | null;
  responsible_name: string;
  auditor_name: string;
  occurrence_date: string;
  deadline_date: string;
  created_at: string;
  status: 'pending' | 'in-progress' | 'resolved' | 'closed';
  department?: Department;
  created_by?: string | null;
  updated_at?: string;
};

export type NonConformanceCreateData = Omit<NonConformance, 'id' | 'code' | 'created_at' | 'department' | 'created_by' | 'updated_at'>;

export type NonConformanceUpdateData = Partial<NonConformanceCreateData>;

export type NonConformanceFilter = {
  status?: NonConformance['status'] | '';
  category?: string | '';
  departmentId?: string | '';
  dateRange?: { from: Date | null; to: Date | null } | null;
  searchTerm?: string;
};

export const useNonConformances = () => {
  const queryClient = useQueryClient();
  const [filters, setFilters] = useState<NonConformanceFilter>({});
  const [error, setError] = useState<Error | null>(null);

  // Function to fetch all non conformances
  const fetchNonConformances = async (): Promise<NonConformance[]> => {
    try {
      let query = supabase
        .from('non_conformances')
        .select(`
          *,
          department:department_id (
            id,
            name
          )
        `)
        .order('created_at', { ascending: false });

      // Apply filters
      if (filters.status) {
        query = query.eq('status', filters.status);
      }

      if (filters.category) {
        query = query.eq('category', filters.category);
      }

      if (filters.departmentId) {
        query = query.eq('department_id', filters.departmentId);
      }

      if (filters.dateRange?.from) {
        query = query.gte('occurrence_date', filters.dateRange.from.toISOString().split('T')[0]);
      }

      if (filters.dateRange?.to) {
        query = query.lte('occurrence_date', filters.dateRange.to.toISOString().split('T')[0]);
      }

      if (filters.searchTerm) {
        query = query.ilike('title', `%${filters.searchTerm}%`);
      }

      const { data, error } = await query;

      if (error) {
        console.error('Error fetching non conformances:', error);
        setError(error);
        throw new Error('Error fetching non conformances');
      }

      return data as unknown as NonConformance[];
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  };

  // Use the useQuery hook to fetch non-conformances
  const { data = [], isLoading, isError, refetch } = useQuery({
    queryKey: ['nonConformances', filters],
    queryFn: fetchNonConformances,
  });

  // Upload files to Supabase storage
  const uploadFiles = async (files: File[]): Promise<string[]> => {
    const uploadPromises = files.map(async (file) => {
      const fileName = `${Date.now()}_${file.name}`;
      const filePath = `evidences/${fileName}`;

      const { error } = await supabase.storage
        .from('non_conformance_files')
        .upload(filePath, file);

      if (error) {
        throw error;
      }

      return filePath;
    });

    return Promise.all(uploadPromises);
  };

  const createNonConformance = useMutation({
    mutationFn: async (data: NonConformanceCreateData) => {
      try {
        // Type assertion to satisfy TypeScript
        const insertData = {
          title: data.title,
          description: data.description,
          location: data.location,
          department_id: data.department_id,
          category: data.category,
          immediate_actions: data.immediate_actions,
          responsible_name: data.responsible_name,
          auditor_name: data.auditor_name,
          occurrence_date: data.occurrence_date,
          deadline_date: data.deadline_date,
          status: data.status,
          // The code field will be auto-generated by a database trigger
          code: 'NC-TEMP' // This value will be overwritten by the trigger
        };

        const { error, data: result } = await supabase
          .from('non_conformances')
          .insert(insertData)
          .select()
          .single();

        if (error) throw new Error(error.message);

        return result as unknown as NonConformance;
      } catch (error) {
        console.error('Error creating non-conformance:', error);
        throw error;
      }
    },
    onSuccess: () => {
      toast({
        title: 'Não conformidade criada',
        description: 'A não conformidade foi criada com sucesso.',
      });
      queryClient.invalidateQueries({ queryKey: ['nonConformances'] });
    },
    onError: (error: any) => {
      toast({
        title: 'Erro',
        description: `Erro ao criar não conformidade: ${error.message}`,
        variant: 'destructive',
      });
    },
  });

  const updateNonConformance = useMutation({
    mutationFn: async ({ id, data }: { id: string, data: NonConformanceUpdateData }) => {
      const { data: updatedData, error } = await supabase
        .from('non_conformances')
        .update(data)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('Error updating non-conformance:', error);
        throw new Error('Error updating non-conformance');
      }

      return updatedData as unknown as NonConformance;
    },
    onSuccess: () => {
      toast({
        title: 'Não conformidade atualizada',
        description: 'A não conformidade foi atualizada com sucesso.',
      });
      queryClient.invalidateQueries({ queryKey: ['nonConformances'] });
    },
    onError: () => {
      toast({
        title: 'Erro',
        description: 'Erro ao atualizar não conformidade.',
        variant: 'destructive',
      });
    },
  });

  const deleteNonConformance = useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('non_conformances')
        .delete()
        .eq('id', id);

      if (error) throw error;

      return { success: true };
    },
    onSuccess: () => {
      toast({
        title: 'Não conformidade excluída',
        description: 'A não conformidade foi excluída com sucesso.',
      });
      queryClient.invalidateQueries({ queryKey: ['nonConformances'] });
    },
    onError: () => {
      toast({
        title: 'Erro',
        description: 'Erro ao excluir não conformidade.',
        variant: 'destructive',
      });
    },
  });

  // Return the necessary data and functions
  return {
    nonConformances: data,
    isLoading,
    isError,
    error,
    refetch,
    createNonConformance,
    updateNonConformance,
    deleteNonConformance,
    uploadFiles,
    filters,
    setFilters,
  };
};
